Help command: kubectl explain namespaces

Namespaces -> Group resources within a cluster
    Initial namespaces:
        - default
        - kube-system
        - kube-node-lease
        - kube-public
    By default, they do not provide network/security boundary
    Useful to put an app or a group of interacting apps in their own namespaces
    Best practice to use them for group things logically

Pods -> Smallest deployable unit where the containers run
    - Can contain multiple containers
    - Networking and storage is shared within a Pods
    - Init container: Runs before startup of the other containers
    - Sidecar container: Runs alongside containers (example: network proxy)
    - Other configs:
        - Ports
        - Health probes
        - Resource requests/limits
        - Security context
        - Env. variables
        - Volumes
        - DNS policies

ReplicaSet -> Takes a pod definition and wraps it in another layer
    - Labels are the link between ReplicaSets and Pods

Deployment -> Adds the concept of "rollouts" and "rollbacks"
    - Used for long-running stateless applications
    - Specify pod specs, how many replicas needed, smoothly move between versions, configs
    - Reapplying a modified yaml template will smoothly replace one pod at a time

Service -> Internal load balancer across replicas
    - Uses pod labels to determine which pods to serve
    - Types:
        - ClusterIP: Internal to cluster
        - NodePort: Listens on each node in cluster
        - LoadBalancer: Provisions external load balancer

Job -> Adds the concept of tracking "completions"
    - Only runs at creation
    - Used for execution of workloads that run to completion
    - It will retry failed attempts (restartPolicy, backoffLimit)
    - More params:
        - parallelism
        - completions
        - activeDeadlineSeconds

CronJob -> Adds the concept of a "schedule"
    - Used for periodic execution of workloads that run to completion
    - Uses cronjob format to spawn jobs but also can be triggered manually (k create job --from)

DaemonSet -> Runs a copy of the specified pod on all (or specified subset of) nodes in the cluster
    - Useful for apps like:
        - Cluster storage
        - Log aggregation
        - Node monitoring

StatefulSet -> Similar to deployment
    - Except:
        - Pods get sticky identity (pod-0, pod-1, etc...)
        - Each pod mounts separate Volumes
        - Rollout behavior is ordered
    - Enables configuring workloads that require state management (primary vs read-replica for DB)
    - Limitations: Most params can't be modified after creation

- - - -

How to configure the primary resources for a specific environment?

ConfigMaps -> Enables environment specific configuration to be decoupled from container images
    - Two primary styles:
        - Property like (MY_ENV_VAR = "MY_VALUE")
        - File like (conf.yaml = <multi-line string>)

Secrets -> Similar to ConfigMaps but data is base64 encoded
    - Supports binary data (alongside string data) but its not a security mechanism
    - It's separate resource type, can be managed with specific auth policies

- - - -

Ingress -> Enables routing traffic to many services via a single external LoadBalancer
    - Many options (Ingress-nginx, HAProxy, King, Istio, Traefik)
    - Officially supports L7 routing (http/https), some implementations allow L4 with additional config
    - Uses paths to route traffic to different services

GatewayAPI -> Evolution of the Ingress API
    - Adds support to TCP/UDP
    - Handles more advanced routing

- - - -

PersistentVolume & PersistentVolumeClaim -> API for creating, managing and consuming persistent storage
    - Lives beyond individual pods
    - Access modes:
        - ReadWriteOnce (and NEW ReadWriteOncePod): Single pod in RW mode (Single pod in RW node even on same node)
        - ReadOnlyMany: Multiple pods mounted in read mode
        - ReadWrite Many: Multiple pods mounted in RW mode (underlying implementation has to support multiple rights consistently)
    - Reclaim policy: Retain vs Delete (retain will not delete the cloud resource)
    - Can be provisioned directly or via StatefulSet

- - - -

RBAC (ServiceAccount, Role, RoleBinding) -> Provides apps or users access to the K8s API
    - Access can be granted by namespace (Role) OR cluster wide (ClusterRole)
    - Used for workloads to access the K8s API and resources within K8s API

- - - -

Labels -> Key-value pairs used to identify and organize K8s resources
    - Can be used to filter api-server queries (e.g. with kubectl)

Annotations -> Key-value pairs used for non-identifying metadata
    - Used for things like configuration details, deployment history
    - Often used by tools to configure specific behaviors (e.g. ingress annotations)

- - - -

Others:
    - LimitRange -> Govern the number of resources a particular object kind can request
    - NetworkPolicy -> Controls network access between network boundaries
    - MutatingWebhookConfiguration -> Change deploy resource requests on the fly (e.g. inject sidecar containers)
    - ValidatingWebhookConfiguration -> Enforce specific standards about characteristics of the resources being deployed (e.g. force deployments to specify memory limit)
    - HorizontalPodAutoscaler -> Automatically scale number of replicas within a deployment / set based on specified metrics
    - CustomResourceDefinition -> Extends the K8s API and define new kind of resources specific to the application

What to use in a demo deployment?

 - Deployments for stateless components
 - StatefulSet for DB (via helm chart)
 - Services for stable network endpoints
 - Ingress for traffic routing
 - ConfigMaps and Secrets for configuration
 - Job for DB migration